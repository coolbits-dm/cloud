<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoolBits.ai Multi-Agent Chat Panel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
            height: 100vh;
            color: #333;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* LEFT SIDEBAR - ENTITIES MENU */
        .entities-sidebar {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
        }

        .entities-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(66, 133, 244, 0.1);
        }

        .entities-header h3 {
            color: #333;
            font-size: 18px;
            font-weight: 600;
        }

        .entities-search {
            margin-top: 0.5rem;
        }

        .entities-search input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .entities-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .entity-category {
            margin-bottom: 1rem;
        }

        .category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: rgba(66, 133, 244, 0.1);
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 0.5rem;
        }

        .category-title {
            font-weight: 600;
            color: #333;
        }

        .category-toggle {
            font-size: 12px;
            color: #666;
        }

        .category-items {
            display: none;
            margin-left: 1rem;
        }

        .category-items.expanded {
            display: block;
        }

        .entity-item {
            padding: 0.75rem;
            margin: 0.25rem 0;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .entity-item:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .entity-item.active {
            border-color: #4285f4;
            background: rgba(66, 133, 244, 0.1);
        }

        .entity-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.25rem;
        }

        .entity-type {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .entity-actions {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .slot-btn {
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .slot-btn.slot-1 { background: #ff6b6b; color: white; }
        .slot-btn.slot-2 { background: #4ecdc4; color: white; }
        .slot-btn.slot-3 { background: #45b7d1; color: white; }
        .slot-btn.slot-4 { background: #96ceb4; color: white; }

        .slot-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .slot-btn.occupied {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
        }

        /* CENTER - WALL CHAT */
        .wall-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
        }

        .wall-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.95);
        }

        .wall-title {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .logo {
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #4285f4, #34a853);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
        }

        .wall-title h1 {
            color: #333;
            font-size: 24px;
            font-weight: 600;
        }

        .wall-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .topic-starter {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .topic-input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .topic-input-group label {
            min-width: 120px;
        }

        .control-label {
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }

        .control-input {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            width: 80px;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4285f4, #34a853);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 1px solid #dee2e6;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        /* AGENT SLOTS */
        .agent-slots {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .agent-slot {
            background: rgba(255, 255, 255, 0.9);
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .agent-slot.occupied {
            border: 2px solid #4285f4;
            background: rgba(66, 133, 244, 0.1);
        }

        .agent-slot:hover {
            border-color: #4285f4;
            background: rgba(66, 133, 244, 0.05);
        }

        .slot-number {
            font-size: 12px;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .slot-agent {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.25rem;
        }

        .slot-status {
            font-size: 12px;
            color: #666;
        }

        .slot-actions {
            margin-top: 0.5rem;
        }

        .remove-agent {
            padding: 0.25rem 0.5rem;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }

        /* WALL CHAT */
        .wall-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.8);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: white;
            max-height: 400px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }

        .chat-message {
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .chat-message.agent-1 {
            background: rgba(255, 107, 107, 0.1);
            border-left: 4px solid #ff6b6b;
            margin-right: auto;
        }

        .chat-message.agent-2 {
            background: rgba(78, 205, 196, 0.1);
            border-left: 4px solid #4ecdc4;
            margin-right: auto;
        }

        .chat-message.agent-3 {
            background: rgba(69, 183, 209, 0.1);
            border-left: 4px solid #45b7d1;
            margin-right: auto;
        }

        .chat-message.agent-4 {
            background: rgba(150, 206, 180, 0.1);
            border-left: 4px solid #96ceb4;
            margin-right: auto;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .message-agent {
            font-weight: 600;
            color: #333;
        }

        .message-time {
            font-size: 12px;
            color: #666;
        }

        .message-content {
            color: #333;
            line-height: 1.5;
        }

        .message-stats {
            font-size: 12px;
            color: #666;
            margin-top: 0.5rem;
        }

        /* RIGHT SIDEBAR - RAG INTEGRATION */
        .rag-sidebar {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
        }

        .rag-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(52, 168, 83, 0.1);
        }

        .rag-header h3 {
            color: #333;
            font-size: 18px;
            font-weight: 600;
        }

        .rag-content {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }

        .rag-section {
            margin-bottom: 1rem;
        }

        .rag-section h4 {
            color: #333;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .rag-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .rag-btn {
            padding: 0.75rem;
            background: rgba(52, 168, 83, 0.1);
            border: 1px solid #34a853;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 14px;
            color: #333;
        }

        .rag-btn:hover {
            background: rgba(52, 168, 83, 0.2);
            transform: translateY(-1px);
        }

        .rag-status {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .status-label {
            font-size: 12px;
            color: #666;
        }

        .status-value {
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }

        /* RESPONSIVE */
        @media (max-width: 1200px) {
            .entities-sidebar, .rag-sidebar {
                width: 250px;
            }
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }
            
            .entities-sidebar, .rag-sidebar {
                width: 100%;
                height: 200px;
            }
            
            .wall-container {
                height: calc(100vh - 400px);
            }
        }

        /* ANIMATIONS */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message {
            animation: fadeIn 0.3s ease;
        }

        .entity-item {
            animation: fadeIn 0.2s ease;
        }

        /* SCROLLBAR STYLING */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(66, 133, 244, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(66, 133, 244, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- LEFT SIDEBAR - ENTITIES MENU -->
        <div class="entities-sidebar">
            <div class="entities-header">
                <h3>🤖 CoolBits.ai Entities</h3>
                <div class="entities-search">
                    <input type="text" id="entity-search" placeholder="Search entities...">
                </div>
            </div>
            <div class="entities-list" id="entities-list">
                <!-- Entities will be loaded here -->
            </div>
        </div>

        <!-- CENTER - WALL CHAT -->
        <div class="wall-container">
            <div class="wall-header">
                <div class="wall-title">
                    <div class="logo">CB</div>
                    <h1>Multi-Agent Chat Wall</h1>
                </div>
                <div class="wall-controls">
                    <div class="control-group">
                        <label class="control-label">Response Interval:</label>
                        <input type="number" class="control-input" id="response-interval" value="30" min="5" max="300">
                        <span style="font-size: 12px; color: #666;">seconds</span>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Max Characters:</label>
                        <input type="number" class="control-input" id="max-characters" value="1000" min="100" max="5000">
                        <span style="font-size: 12px; color: #666;">chars</span>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Cycles:</label>
                        <input type="number" class="control-input" id="max-cycles" value="3" min="1" max="10">
                        <span style="font-size: 12px; color: #666;">rounds</span>
                    </div>
                    <button class="btn btn-primary" onclick="startTopicDiscussion()">Start Topic Discussion</button>
                    <button class="btn btn-secondary" onclick="stopChat()">Stop Chat</button>
                    <button class="btn btn-danger" onclick="clearWall()">Clear Wall</button>
                </div>
                
                <!-- Topic Starter Input -->
                <div class="topic-starter" id="topic-starter" style="display: none;">
                    <div class="topic-input-group">
                        <label class="control-label">Discussion Topic:</label>
                        <input type="text" class="control-input" id="topic-title" placeholder="Enter discussion title..." style="width: 300px;">
                    </div>
                    <div class="topic-input-group">
                        <label class="control-label">Description:</label>
                        <textarea class="control-input" id="topic-description" placeholder="Describe the discussion topic..." style="width: 400px; height: 60px;"></textarea>
                    </div>
                    <button class="btn btn-success" onclick="initiateDiscussion()">Initiate Discussion</button>
                    <button class="btn btn-secondary" onclick="hideTopicStarter()">Cancel</button>
                </div>
            </div>

            <!-- AGENT SLOTS -->
            <div class="agent-slots">
                <div class="agent-slot" id="slot-1" onclick="selectSlot(1)">
                    <div class="slot-number">Slot 1</div>
                    <div class="slot-agent" id="slot-1-agent">Add Agent</div>
                    <div class="slot-status" id="slot-1-status">Available</div>
                    <div class="slot-actions" id="slot-1-actions" style="display: none;">
                        <button class="remove-agent" onclick="removeAgent(1)">Remove</button>
                    </div>
                </div>
                <div class="agent-slot" id="slot-2" onclick="selectSlot(2)">
                    <div class="slot-number">Slot 2</div>
                    <div class="slot-agent" id="slot-2-agent">Add Agent</div>
                    <div class="slot-status" id="slot-2-status">Available</div>
                    <div class="slot-actions" id="slot-2-actions" style="display: none;">
                        <button class="remove-agent" onclick="removeAgent(2)">Remove</button>
                    </div>
                </div>
                <div class="agent-slot" id="slot-3" onclick="selectSlot(3)">
                    <div class="slot-number">Slot 3</div>
                    <div class="slot-agent" id="slot-3-agent">Add Agent</div>
                    <div class="slot-status" id="slot-3-status">Available</div>
                    <div class="slot-actions" id="slot-3-actions" style="display: none;">
                        <button class="remove-agent" onclick="removeAgent(3)">Remove</button>
                    </div>
                </div>
                <div class="agent-slot" id="slot-4" onclick="selectSlot(4)">
                    <div class="slot-number">Slot 4</div>
                    <div class="slot-agent" id="slot-4-agent">Add Agent</div>
                    <div class="slot-status" id="slot-4-status">Available</div>
                    <div class="slot-actions" id="slot-4-actions" style="display: none;">
                        <button class="remove-agent" onclick="removeAgent(4)">Remove</button>
                    </div>
                </div>
            </div>

            <!-- WALL CHAT -->
            <div class="wall-chat">
                <div class="chat-messages" id="chat-messages">
                    <div style="text-align: center; color: #666; padding: 2rem;">
                        <h3>Welcome to Multi-Agent Chat Wall</h3>
                        <p>Add agents to slots and start the conversation!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT SIDEBAR - RAG INTEGRATION -->
        <div class="rag-sidebar">
            <div class="rag-header">
                <h3>🧠 RAG Integration</h3>
            </div>
            <div class="rag-content">
                <div class="rag-status">
                    <h4>System Status</h4>
                    <div class="status-item">
                        <span class="status-label">Active Agents:</span>
                        <span class="status-value" id="active-agents">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Messages:</span>
                        <span class="status-value" id="total-messages">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">RAG Status:</span>
                        <span class="status-value" id="rag-status">Ready</span>
                    </div>
                </div>

                <div class="rag-section">
                    <h4>Knowledge Management</h4>
                    <div class="rag-actions">
                        <button class="rag-btn" onclick="saveConversation()">Save to RAG</button>
                        <button class="rag-btn" onclick="searchRAG()">Search RAG</button>
                        <button class="rag-btn" onclick="exportConversation()">Export Chat</button>
                    </div>
                </div>

                <div class="rag-section">
                    <h4>Auto Actions</h4>
                    <div class="rag-actions">
                        <button class="rag-btn" onclick="toggleAutoSave()">Auto Save</button>
                        <button class="rag-btn" onclick="toggleAutoSearch()">Auto Search</button>
                    </div>
                </div>

                <div class="rag-section">
                    <h4>RAG Domains</h4>
                    <div id="rag-domains">
                        <!-- RAG domains will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let entities = [];
        let activeAgents = {};
        let chatInterval = null;
        let isChatActive = false;
        let messageCount = 0;
        let selectedEntity = null;
        let selectedSlot = null;
        let currentSessionId = null;
        let websocket = null;
        let lastResponseTime = {};
        let responseCount = {};
        let isGeneratingResponse = false; // Prevent concurrent responses
        
        // New Context Engine State
        let conversationContext = [];
        let currentCycle = 0;
        let currentSlotIndex = 0;
        let maxCycles = 3;
        let discussionTopic = null;
        let discussionDescription = null;
        let isOrderedMode = false;

        // Initialize the panel
        document.addEventListener('DOMContentLoaded', function() {
            loadEntities();
            setupEventListeners();
            updateStatus();
        });

        function setupEventListeners() {
            // Entity search
            document.getElementById('entity-search').addEventListener('input', filterEntities);
            
            // Control inputs
            document.getElementById('response-interval').addEventListener('change', updateSettings);
            document.getElementById('max-characters').addEventListener('change', updateSettings);
        }

        async function loadEntities() {
            try {
                const response = await fetch('http://localhost:8096/api/agents');
                const data = await response.json();
                entities = data.agents;
                
                updateEntityList();
                loadRAGDomains();
                
            } catch (error) {
                console.error('Error loading entities:', error);
                // Fallback to mock data
                entities = [
                    { id: 'ceo', name: 'CEO', type: 'role', category: 'Leadership', description: 'Chief Executive Officer', api_keys: { openai: true, xai: true } },
                    { id: 'cto', name: 'CTO', type: 'role', category: 'Leadership', description: 'Chief Technology Officer', api_keys: { openai: true, xai: true } },
                    { id: 'fintech', name: 'FinTech Expert', type: 'industry', category: 'Financial', description: 'Financial Technology Specialist', api_keys: { openai: true, xai: true } },
                    { id: 'blockchain', name: 'Blockchain Expert', type: 'industry', category: 'Technology', description: 'Blockchain and Crypto Specialist', api_keys: { openai: true, xai: true } },
                ];
                updateEntityList();
            }
        }

        function updateEntityList() {
            const entitiesList = document.getElementById('entities-list');
            
            // Group entities by category
            const categories = {};
            entities.forEach(entity => {
                if (!categories[entity.category]) {
                    categories[entity.category] = [];
                }
                categories[entity.category].push(entity);
            });
            
            const categoriesHtml = Object.keys(categories).map(categoryName => {
                const categoryEntities = categories[categoryName];
                const entitiesHtml = categoryEntities.map(entity => `
                    <div class="entity-item" onclick="selectEntity('${entity.id}')">
                        <div class="entity-name">${entity.name}</div>
                        <div class="entity-type">${entity.type} • ${entity.description}</div>
                        <div class="entity-actions">
                            <button class="slot-btn slot-1" onclick="assignToSlot(1, '${entity.id}')">Slot 1</button>
                            <button class="slot-btn slot-2" onclick="assignToSlot(2, '${entity.id}')">Slot 2</button>
                            <button class="slot-btn slot-3" onclick="assignToSlot(3, '${entity.id}')">Slot 3</button>
                            <button class="slot-btn slot-4" onclick="assignToSlot(4, '${entity.id}')">Slot 4</button>
                        </div>
                    </div>
                `).join('');
                
                return `
                    <div class="entity-category">
                        <div class="category-header" onclick="toggleCategory('${categoryName}')">
                            <span class="category-title">${categoryName} (${categoryEntities.length})</span>
                            <span class="category-toggle">▼</span>
                        </div>
                        <div class="category-items" id="category-${categoryName}">
                            ${entitiesHtml}
                        </div>
                    </div>
                `;
            }).join('');
            
            entitiesList.innerHTML = categoriesHtml;
            updateSlotButtons();
        }

        function toggleCategory(categoryName) {
            const categoryItems = document.getElementById(`category-${categoryName}`);
            const toggle = categoryItems.previousElementSibling.querySelector('.category-toggle');
            
            if (categoryItems.classList.contains('expanded')) {
                categoryItems.classList.remove('expanded');
                toggle.textContent = '▶';
            } else {
                categoryItems.classList.add('expanded');
                toggle.textContent = '▼';
            }
        }

        function filterEntities() {
            const searchTerm = document.getElementById('entity-search').value.toLowerCase();
            const entityItems = document.querySelectorAll('.entity-item');
            
            entityItems.forEach(item => {
                const entityName = item.querySelector('.entity-name').textContent.toLowerCase();
                const entityType = item.querySelector('.entity-type').textContent.toLowerCase();
                
                if (entityName.includes(searchTerm) || entityType.includes(searchTerm)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        function selectEntity(entityId) {
            selectedEntity = entities.find(e => e.id === entityId);
            
            // Update visual selection
            document.querySelectorAll('.entity-item').forEach(item => item.classList.remove('active'));
            event.target.closest('.entity-item').classList.add('active');
        }

        function assignToSlot(slotNumber, entityId) {
            const entity = entities.find(e => e.id === entityId);
            if (!entity) return;
            
            // Check if slot is already occupied
            if (activeAgents[slotNumber]) {
                if (confirm(`Slot ${slotNumber} is already occupied. Replace ${activeAgents[slotNumber].name}?`)) {
                    removeAgent(slotNumber);
                } else {
                    return;
                }
            }
            
            // Assign entity to slot
            activeAgents[slotNumber] = entity;
            
            // Update slot UI
            const slotElement = document.getElementById(`slot-${slotNumber}`);
            const agentElement = document.getElementById(`slot-${slotNumber}-agent`);
            const statusElement = document.getElementById(`slot-${slotNumber}-status`);
            const actionsElement = document.getElementById(`slot-${slotNumber}-actions`);
            
            slotElement.classList.add('occupied');
            agentElement.textContent = entity.name;
            statusElement.textContent = 'Active';
            actionsElement.style.display = 'block';
            
            updateSlotButtons();
            updateStatus();
        }

        function removeAgent(slotNumber) {
            if (!activeAgents[slotNumber]) return;
            
            delete activeAgents[slotNumber];
            
            // Update slot UI
            const slotElement = document.getElementById(`slot-${slotNumber}`);
            const agentElement = document.getElementById(`slot-${slotNumber}-agent`);
            const statusElement = document.getElementById(`slot-${slotNumber}-status`);
            const actionsElement = document.getElementById(`slot-${slotNumber}-actions`);
            
            slotElement.classList.remove('occupied');
            agentElement.textContent = 'Add Agent';
            statusElement.textContent = 'Available';
            actionsElement.style.display = 'none';
            
            updateSlotButtons();
            updateStatus();
        }

        function updateSlotButtons() {
            // Update slot buttons based on availability
            document.querySelectorAll('.slot-btn').forEach(btn => {
                const slotNumber = parseInt(btn.classList[1].split('-')[1]);
                if (activeAgents[slotNumber]) {
                    btn.classList.add('occupied');
                    btn.disabled = true;
                } else {
                    btn.classList.remove('occupied');
                    btn.disabled = false;
                }
            });
        }

        function selectSlot(slotNumber) {
            selectedSlot = slotNumber;
            
            // Update visual selection
            document.querySelectorAll('.agent-slot').forEach(slot => slot.classList.remove('selected'));
            document.getElementById(`slot-${slotNumber}`).classList.add('selected');
        }

        function startChat() {
            const activeAgentCount = Object.keys(activeAgents).length;
            if (activeAgentCount < 2) {
                alert('Please assign at least 2 agents to start the chat!');
                return;
            }
            
            isChatActive = true;
            const interval = parseInt(document.getElementById('response-interval').value) * 1000;
            
            chatInterval = setInterval(() => {
                if (isChatActive) {
                    generateAgentResponse();
                }
            }, interval);
            
            // Add welcome message
            addMessage('system', 'Chat started! Agents will respond every ' + (interval / 1000) + ' seconds.');
            
            updateStatus();
        }

        function stopChat() {
            isChatActive = false;
            if (chatInterval) {
                clearInterval(chatInterval);
                chatInterval = null;
            }
            
            addMessage('system', 'Chat stopped.');
            updateStatus();
        }

        function clearWall() {
            if (confirm('Are you sure you want to clear all messages?')) {
                document.getElementById('chat-messages').innerHTML = `
                    <div style="text-align: center; color: #666; padding: 2rem;">
                        <h3>Welcome to Multi-Agent Chat Wall</h3>
                        <p>Add agents to slots and start the conversation!</p>
                    </div>
                `;
                messageCount = 0;
                conversationContext = [];
                currentCycle = 0;
                currentSlotIndex = 0;
                discussionTopic = null;
                discussionDescription = null;
                isOrderedMode = false;
                updateStatus();
            }
        }

        // New Topic Discussion Functions
        function startTopicDiscussion() {
            const activeAgentCount = Object.keys(activeAgents).length;
            if (activeAgentCount < 2) {
                alert('Please assign at least 2 agents to start the discussion!');
                return;
            }
            
            document.getElementById('topic-starter').style.display = 'block';
        }

        function getActiveMembers() {
            const activeMembers = [];
            for (let slot = 1; slot <= 4; slot++) {
                const agent = activeAgents[slot];
                if (agent) {
                    activeMembers.push(`${agent.name} (Slot ${slot})`);
                }
            }
            return activeMembers;
        }

        function hideTopicStarter() {
            document.getElementById('topic-starter').style.display = 'none';
        }

        async function initiateDiscussion() {
            const title = document.getElementById('topic-title').value.trim();
            const description = document.getElementById('topic-description').value.trim();
            
            if (!title || !description) {
                alert('Please enter both title and description for the discussion!');
                return;
            }
            
            discussionTopic = title;
            discussionDescription = description;
            maxCycles = parseInt(document.getElementById('max-cycles').value);
            isOrderedMode = true;
            currentCycle = 0;
            currentSlotIndex = 0;
            conversationContext = [];
            
            // Hide topic starter
            hideTopicStarter();
            
            // Create session
            if (!currentSessionId) {
                currentSessionId = await createSession();
                if (!currentSessionId) return;
            }
            
            // Add Andrei's initial message with active members
            const activeMembers = getActiveMembers();
            const initialMessage = `🎯 DISCUSSION TOPIC: ${title}\n\n📝 DESCRIPTION: ${description}\n\n👤 Initiated by: Andrei (CEO CoolBits.ai)\n\n👥 ACTIVE DISCUSSION MEMBERS:\n${activeMembers.map(member => `   • ${member}`).join('\n')}\n\nLet's begin the discussion!`;
            addMessage('system', initialMessage, 'Andrei');
            
            // Add to context
            conversationContext.push({
                role: 'user',
                content: `Discussion Topic: ${title}\nDescription: ${description}`,
                timestamp: new Date().toISOString()
            });
            
            // Start ordered discussion
            await startOrderedDiscussion();
        }

        async function startOrderedDiscussion() {
            isChatActive = true;
            currentSlotIndex = 0; // Start with slot 1
            
            const interval = parseInt(document.getElementById('response-interval').value) * 1000;
            
            chatInterval = setInterval(() => {
                if (isChatActive && isOrderedMode) {
                    generateOrderedResponse();
                }
            }, interval);
            
            // Connect to WebSocket for real-time updates
            connectWebSocket();
            
            addMessage('system', `Ordered discussion started! ${maxCycles} cycles planned. Agents will respond in order: Slot 1 → Slot 2 → Slot 3 → Slot 4.`);
            updateStatus();
        }

        async function generateOrderedResponse() {
            if (!currentSessionId || isGeneratingResponse || !isOrderedMode) return;
            
            isGeneratingResponse = true;
            
            try {
                const activeAgentIds = Object.keys(activeAgents);
                if (activeAgentIds.length === 0) {
                    return;
                }
                
                // Get current slot (1-based)
                const currentSlot = currentSlotIndex + 1;
                const agent = activeAgents[currentSlot];
                
                if (!agent) {
                    console.log(`No agent in slot ${currentSlot}, skipping...`);
                    return;
                }
                
                console.log(`🔄 Cycle ${currentCycle + 1}, Slot ${currentSlot}: ${agent.name} responding...`);
                
                // Prepare context for the agent
                const contextForAgent = prepareContextForAgent(agent, currentSlot);
                
                // Generate response using real API
                const response = await generateRealAgentResponse(agent, contextForAgent, currentSlot);
                
                if (response) {
                    addMessage(`agent-${currentSlot}`, response, agent.name);
                    
                    // Add to conversation context
                    conversationContext.push({
                        role: 'assistant',
                        content: response,
                        agent: agent.name,
                        slot: currentSlot,
                        timestamp: new Date().toISOString()
                    });
                    
                    console.log(`✅ ${agent.name} responded in cycle ${currentCycle + 1}`);
                    
                    // Move to next slot
                    currentSlotIndex = (currentSlotIndex + 1) % activeAgentIds.length;
                    
                    // Check if cycle is complete
                    if (currentSlotIndex === 0) {
                        currentCycle++;
                        console.log(`🔄 Completed cycle ${currentCycle}/${maxCycles}`);
                        
                        if (currentCycle >= maxCycles) {
                            console.log(`🏁 Discussion completed after ${maxCycles} cycles`);
                            stopChat();
                            addMessage('system', `Discussion completed after ${maxCycles} cycles. Thank you for participating!`);
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error generating ordered response:', error);
            } finally {
                isGeneratingResponse = false;
            }
        }

        function prepareContextForAgent(agent, slot) {
            // Prepare full conversation context for the agent
            let context = `You are ${agent.name}, ${agent.description || 'an AI agent'}.\n\n`;
            context += `Discussion Topic: ${discussionTopic}\n`;
            context += `Description: ${discussionDescription}\n\n`;
            context += `Current Cycle: ${currentCycle + 1}/${maxCycles}\n`;
            context += `Your turn to respond (Slot ${slot})\n\n`;
            
            context += `Previous conversation:\n`;
            conversationContext.forEach((msg, index) => {
                if (msg.role === 'user') {
                    context += `User: ${msg.content}\n`;
                } else {
                    context += `${msg.agent}: ${msg.content}\n`;
                }
            });
            
            context += `\nPlease provide your response to the discussion topic, considering all previous messages. Keep it under ${document.getElementById('max-characters').value} characters.`;
            
            return context;
        }

        async function generateRealAgentResponse(agent, context, slot) {
            try {
                // Get API key from Google Cloud Secrets Manager
                const apiKey = await getAPIKeyFromSecrets(agent);
                const apiProvider = agent.api_keys?.openai ? 'openai' : 'xai';
                
                if (!apiKey) {
                    console.error(`No API key found for agent ${agent.name}`);
                    return `I apologize, but I don't have access to my API key to respond properly.`;
                }
                
                console.log(`🔑 Using ${apiProvider.toUpperCase()} API for ${agent.name}`);
                
                // Make real API call
                const response = await makeRealAPICall(apiProvider, apiKey, context, agent);
                return response;
                
            } catch (error) {
                console.error(`Error generating response for ${agent.name}:`, error);
                return `I encountered an error while generating my response: ${error.message}`;
            }
        }

        async function getAPIKeyFromSecrets(agent) {
            try {
                // Determine which API key to use based on agent configuration
                const secretName = agent.api_keys?.openai ? 'ocopilot-openai-key' : 'ocopilot-xai-key';
                
                console.log(`🔍 Retrieving ${secretName} from Google Cloud Secrets Manager...`);
                
                // Call backend to retrieve secret from Google Cloud
                const response = await fetch(`http://localhost:8096/api/secrets/${secretName}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(`✅ Retrieved API key for ${agent.name}`);
                    return data.secret_value;
                } else {
                    console.error(`❌ Failed to retrieve secret: ${response.statusText}`);
                    return null;
                }
                
            } catch (error) {
                console.error(`Error retrieving API key for ${agent.name}:`, error);
                return null;
            }
        }

        async function makeRealAPICall(provider, apiKey, context, agent) {
            try {
                console.log(`🚀 Making ${provider.toUpperCase()} API call for ${agent.name}...`);
                
                const maxChars = parseInt(document.getElementById('max-characters').value);
                
                if (provider === 'openai') {
                    return await callOpenAIAPI(apiKey, context, maxChars);
                } else if (provider === 'xai') {
                    return await callXAIAPI(apiKey, context, maxChars);
                } else {
                    throw new Error(`Unsupported API provider: ${provider}`);
                }
                
            } catch (error) {
                console.error(`Error making ${provider} API call:`, error);
                throw error;
            }
        }

        async function callOpenAIAPI(apiKey, context, maxChars) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are participating in a professional business discussion. Provide thoughtful, concise responses that contribute meaningfully to the conversation.'
                            },
                            {
                                role: 'user',
                                content: context
                            }
                        ],
                        max_tokens: Math.floor(maxChars / 4), // Rough estimation
                        temperature: 0.7,
                        top_p: 1,
                        frequency_penalty: 0,
                        presence_penalty: 0
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`OpenAI API error: ${errorData.error?.message || response.statusText}`);
                }
                
                const data = await response.json();
                const content = data.choices[0]?.message?.content || 'No response generated';
                
                console.log(`✅ OpenAI API response received (${content.length} chars)`);
                return content;
                
            } catch (error) {
                console.error('OpenAI API call failed:', error);
                throw error;
            }
        }

        async function callXAIAPI(apiKey, context, maxChars) {
            try {
                const response = await fetch('https://api.x.ai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'grok-2-1212',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are participating in a professional business discussion. Provide thoughtful, concise responses that contribute meaningfully to the conversation.'
                            },
                            {
                                role: 'user',
                                content: context
                            }
                        ],
                        max_tokens: Math.floor(maxChars / 4), // Rough estimation
                        temperature: 0.7,
                        top_p: 1,
                        frequency_penalty: 0,
                        presence_penalty: 0
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`xAI API error: ${errorData.error?.message || response.statusText}`);
                }
                
                const data = await response.json();
                const content = data.choices[0]?.message?.content || 'No response generated';
                
                console.log(`✅ xAI API response received (${content.length} chars)`);
                return content;
                
            } catch (error) {
                console.error('xAI API call failed:', error);
                throw error;
            }
        }

        async function generateAgentResponse() {
            const activeAgentIds = Object.keys(activeAgents);
            if (activeAgentIds.length === 0) return;
            
            // Select random active agent
            const randomSlot = activeAgentIds[Math.floor(Math.random() * activeAgentIds.length)];
            const agent = activeAgents[randomSlot];
            
            // Generate response (mock for now)
            const response = await generateMockResponse(agent);
            
            addMessage(`agent-${randomSlot}`, response, agent.name);
        }

        async function generateMockResponse(agent) {
            // Mock response generation - will be replaced with real API calls
            const responses = [
                `As ${agent.name}, I believe we should focus on strategic growth and innovation.`,
                `From my perspective as ${agent.name}, the key is to maintain operational excellence.`,
                `I think we need to consider the market dynamics and competitive landscape.`,
                `Based on my experience in ${agent.type}, I recommend a data-driven approach.`,
                `We should prioritize customer satisfaction and stakeholder value.`,
                `The technology landscape is evolving rapidly, and we must adapt accordingly.`,
                `Financial sustainability should be our primary concern in this context.`,
                `Innovation and creativity will drive our competitive advantage.`
            ];
            
            const maxChars = parseInt(document.getElementById('max-characters').value);
            let response = responses[Math.floor(Math.random() * responses.length)];
            
            // Truncate if too long
            if (response.length > maxChars) {
                response = response.substring(0, maxChars - 3) + '...';
            }
            
            return response;
        }

        function addMessage(type, content, agentName = 'System') {
            const chatMessages = document.getElementById('chat-messages');
            
            // Remove welcome message if it exists
            const welcomeMsg = chatMessages.querySelector('div[style*="text-align: center"]');
            if (welcomeMsg) {
                welcomeMsg.remove();
            }
            
            // Limit total messages to prevent memory issues
            const maxMessages = 100;
            const existingMessages = chatMessages.querySelectorAll('.chat-message');
            if (existingMessages.length >= maxMessages) {
                // Remove oldest messages
                for (let i = 0; i < 10; i++) {
                    if (existingMessages[i]) {
                        existingMessages[i].remove();
                    }
                }
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;
            
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="message-agent">${agentName}</span>
                    <span class="message-time">${timeString}</span>
                </div>
                <div class="message-content">${content}</div>
                <div class="message-stats">Characters: ${content.length}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            
            // Auto-scroll to bottom with smooth animation
            setTimeout(() => {
                chatMessages.scrollTo({
                    top: chatMessages.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
            
            messageCount++;
            updateStatus();
        }

        function updateStatus() {
            document.getElementById('active-agents').textContent = Object.keys(activeAgents).length;
            document.getElementById('total-messages').textContent = messageCount;
            document.getElementById('rag-status').textContent = isChatActive ? 'Active' : 'Ready';
        }

        function updateSettings() {
            // Settings updated
            console.log('Settings updated');
        }

        // RAG Integration Functions
        async function saveConversation() {
            const messages = document.querySelectorAll('.chat-message');
            const conversation = Array.from(messages).map(msg => ({
                agent: msg.querySelector('.message-agent').textContent,
                content: msg.querySelector('.message-content').textContent,
                time: msg.querySelector('.message-time').textContent
            }));
            
            // Mock save to RAG
            console.log('Saving conversation to RAG:', conversation);
            alert('Conversation saved to RAG successfully!');
        }

        async function searchRAG() {
            const query = prompt('Enter search query:');
            if (query) {
                // Mock RAG search
                console.log('Searching RAG for:', query);
                alert(`RAG search results for "${query}" would be displayed here.`);
            }
        }

        function exportConversation() {
            const messages = document.querySelectorAll('.chat-message');
            const conversation = Array.from(messages).map(msg => ({
                agent: msg.querySelector('.message-agent').textContent,
                content: msg.querySelector('.message-content').textContent,
                time: msg.querySelector('.message-time').textContent
            }));
            
            const dataStr = JSON.stringify(conversation, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `chat-export-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        function toggleAutoSave() {
            // Toggle auto-save functionality
            console.log('Auto-save toggled');
        }

        function toggleAutoSearch() {
            // Toggle auto-search functionality
            console.log('Auto-search toggled');
        }

        // Session Management Functions
        async function createSession() {
            try {
                const responseInterval = parseInt(document.getElementById('response-interval').value);
                const maxCharacters = parseInt(document.getElementById('max-characters').value);
                
                const response = await fetch('http://localhost:8096/api/session/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        response_interval: responseInterval,
                        max_characters: maxCharacters
                    })
                });
                
                const data = await response.json();
                currentSessionId = data.session_id;
                
                console.log('Session created:', currentSessionId);
                return currentSessionId;
                
            } catch (error) {
                console.error('Error creating session:', error);
                return null;
            }
        }

        async function assignToSlot(slotNumber, entityId) {
            if (!currentSessionId) {
                currentSessionId = await createSession();
                if (!currentSessionId) return;
            }
            
            try {
                const response = await fetch(`http://localhost:8096/api/session/${currentSessionId}/assign-agent?slot=${slotNumber}&agent_id=${entityId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const entity = entities.find(e => e.id === entityId);
                    if (entity) {
                        activeAgents[slotNumber] = entity;
                        updateSlotUI(slotNumber, entity);
                        updateSlotButtons();
                        updateStatus();
                    }
                } else {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                }
                
            } catch (error) {
                console.error('Error assigning agent:', error);
                alert('Error assigning agent to slot');
            }
        }

        async function removeAgent(slotNumber) {
            if (!currentSessionId) return;
            
            try {
                const response = await fetch(`http://localhost:8096/api/session/${currentSessionId}/remove-agent/${slotNumber}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    delete activeAgents[slotNumber];
                    updateSlotUI(slotNumber, null);
                    updateSlotButtons();
                    updateStatus();
                }
                
            } catch (error) {
                console.error('Error removing agent:', error);
            }
        }

        function updateSlotUI(slotNumber, entity) {
            const slotElement = document.getElementById(`slot-${slotNumber}`);
            const agentElement = document.getElementById(`slot-${slotNumber}-agent`);
            const statusElement = document.getElementById(`slot-${slotNumber}-status`);
            const actionsElement = document.getElementById(`slot-${slotNumber}-actions`);
            
            if (entity) {
                slotElement.classList.add('occupied');
                agentElement.textContent = entity.name;
                statusElement.textContent = 'Active';
                actionsElement.style.display = 'block';
            } else {
                slotElement.classList.remove('occupied');
                agentElement.textContent = 'Add Agent';
                statusElement.textContent = 'Available';
                actionsElement.style.display = 'none';
            }
        }

        async function startChat() {
            const activeAgentCount = Object.keys(activeAgents).length;
            if (activeAgentCount < 2) {
                alert('Please assign at least 2 agents to start the chat!');
                return;
            }
            
            if (!currentSessionId) {
                currentSessionId = await createSession();
                if (!currentSessionId) return;
            }
            
            try {
                const response = await fetch(`http://localhost:8096/api/session/${currentSessionId}/start`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    isChatActive = true;
                    
                    // Reset response counters for new chat
                    lastResponseTime = {};
                    responseCount = {};
                    isGeneratingResponse = false;
                    
                    const interval = parseInt(document.getElementById('response-interval').value) * 1000;
                    
                    chatInterval = setInterval(() => {
                        if (isChatActive) {
                            generateAgentResponse();
                        }
                    }, interval);
                    
                    // Connect to WebSocket for real-time updates
                    connectWebSocket();
                    
                    addMessage('system', 'Chat started! Agents will respond every ' + (interval / 1000) + ' seconds.');
                    updateStatus();
                } else {
                    const error = await response.json();
                    alert(`Error starting chat: ${error.detail}`);
                }
                
            } catch (error) {
                console.error('Error starting chat:', error);
                alert('Error starting chat');
            }
        }

        async function stopChat() {
            if (!currentSessionId) return;
            
            try {
                const response = await fetch(`http://localhost:8096/api/session/${currentSessionId}/stop`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    isChatActive = false;
                    if (chatInterval) {
                        clearInterval(chatInterval);
                        chatInterval = null;
                    }
                    
                    if (websocket) {
                        websocket.close();
                        websocket = null;
                    }
                    
                    // Reset response counters
                    lastResponseTime = {};
                    responseCount = {};
                    isGeneratingResponse = false;
                    
                    addMessage('system', 'Chat stopped.');
                    updateStatus();
                }
                
            } catch (error) {
                console.error('Error stopping chat:', error);
            }
        }

        async function generateAgentResponse() {
            if (!currentSessionId || isGeneratingResponse) return;
            
            isGeneratingResponse = true;
            
            try {
                const activeAgentIds = Object.keys(activeAgents);
                if (activeAgentIds.length === 0) {
                    return;
                }
                
                // Select random active agent
                const randomSlot = parseInt(activeAgentIds[Math.floor(Math.random() * activeAgentIds.length)]);
                const agent = activeAgents[randomSlot];
                
                // Prevent spam - check if agent responded recently
                const now = Date.now();
                const agentKey = `${agent.id}_${randomSlot}`;
                const lastTime = lastResponseTime[agentKey] || 0;
                const minInterval = parseInt(document.getElementById('response-interval').value) * 1000;
                
                // Debug logging
                console.log(`🔍 Checking agent ${agent.name} (${agentKey}):`);
                console.log(`- Last response: ${lastTime} (${lastTime ? new Date(lastTime).toLocaleTimeString() : 'never'})`);
                console.log(`- Current time: ${now} (${new Date(now).toLocaleTimeString()})`);
                console.log(`- Time diff: ${now - lastTime}ms`);
                console.log(`- Min interval: ${minInterval}ms (${document.getElementById('response-interval').value}s)`);
                
                if (now - lastTime < minInterval) {
                    console.log(`❌ Agent ${agent.name} responded too recently, skipping... (need ${minInterval - (now - lastTime)}ms more)`);
                    return;
                }
                
                // Limit responses per agent per session
                responseCount[agentKey] = (responseCount[agentKey] || 0) + 1;
                if (responseCount[agentKey] > 50) { // Max 50 responses per agent
                    console.log(`❌ Agent ${agent.name} reached response limit, skipping...`);
                    return;
                }
                
                // Set timestamp BEFORE making request to prevent race conditions
                lastResponseTime[agentKey] = now;
                
                console.log(`✅ Agent ${agent.name} can respond (count: ${responseCount[agentKey]})`);
                
                const response = await fetch(`http://localhost:8096/api/session/${currentSessionId}/generate-response?agent_id=${agent.id}&slot=${randomSlot}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    addMessage(`agent-${randomSlot}`, data.content, agent.name);
                    console.log(`✅ Response added from ${agent.name}`);
                }
                
            } catch (error) {
                console.error('Error generating response:', error);
            } finally {
                isGeneratingResponse = false;
            }
        }

        function connectWebSocket() {
            if (!currentSessionId) return;
            
            websocket = new WebSocket(`ws://localhost:8096/ws/${currentSessionId}`);
            
            websocket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type === 'message') {
                    const message = data.data;
                    addMessage(`agent-${message.slot_number}`, message.content, message.agent_name);
                }
            };
            
            websocket.onclose = function() {
                console.log('WebSocket connection closed');
            };
            
            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        // RAG Integration Functions
        async function loadRAGDomains() {
            try {
                const response = await fetch('http://localhost:8094/domains');
                const data = await response.json();
                
                const ragDomainsDiv = document.getElementById('rag-domains');
                const domainsHtml = data.domains.map(domain => `
                    <div style="background: rgba(255, 255, 255, 0.8); border-radius: 6px; padding: 0.5rem; margin: 0.25rem 0;">
                        <div style="font-weight: 600; font-size: 12px; color: #333;">${domain.domain_name}</div>
                        <div style="font-size: 10px; color: #666;">${domain.documents_count} docs</div>
                    </div>
                `).join('');
                
                ragDomainsDiv.innerHTML = domainsHtml;
                
            } catch (error) {
                console.error('Error loading RAG domains:', error);
                document.getElementById('rag-domains').innerHTML = '<div style="color: #666; font-size: 12px;">RAG not available</div>';
            }
        }

        async function saveConversation() {
            if (!currentSessionId) return;
            
            try {
                const response = await fetch(`http://localhost:8096/api/session/${currentSessionId}/messages`);
                const data = await response.json();
                
                // Save to RAG system
                const conversationText = data.messages.map(msg => 
                    `${msg.agent_name}: ${msg.content}`
                ).join('\n\n');
                
                // Save to CEO domain as example
                const ragResponse = await fetch('http://localhost:8094/domains/ceo/add-document', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        domain_id: 'ceo',
                        title: `Multi-Agent Chat - ${new Date().toLocaleDateString()}`,
                        content: conversationText,
                        doc_type: 'conversation',
                        metadata: {
                            session_id: currentSessionId,
                            total_messages: data.total_messages,
                            agents: Object.keys(activeAgents).map(slot => activeAgents[slot].name)
                        },
                        vertex_metadata: {
                            source: 'multi_agent_chat',
                            session_id: currentSessionId
                        }
                    })
                });
                
                if (ragResponse.ok) {
                    alert('Conversation saved to RAG successfully!');
                } else {
                    alert('Error saving to RAG');
                }
                
            } catch (error) {
                console.error('Error saving conversation:', error);
                alert('Error saving conversation');
            }
        }

        async function searchRAG() {
            const query = prompt('Enter search query:');
            if (!query) return;
            
            try {
                const response = await fetch('http://localhost:8094/domains/ceo/vector-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        domain_id: 'ceo',
                        query: query,
                        max_results: 5,
                        similarity_threshold: 0.7,
                        use_vertex_format: true
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    let results = `RAG Search Results for "${query}":\n\n`;
                    
                    if (data.results.length > 0) {
                        data.results.forEach((result, index) => {
                            results += `${index + 1}. ${result.title} (${(result.similarity_score * 100).toFixed(1)}%)\n${result.content}\n\n`;
                        });
                    } else {
                        results += 'No relevant documents found.';
                    }
                    
                    alert(results);
                } else {
                    alert('Error searching RAG');
                }
                
            } catch (error) {
                console.error('Error searching RAG:', error);
                alert('Error searching RAG');
            }
        }

        function exportConversation() {
            if (!currentSessionId) return;
            
            fetch(`http://localhost:8096/api/session/${currentSessionId}/messages`)
                .then(response => response.json())
                .then(data => {
                    const conversation = data.messages.map(msg => ({
                        agent: msg.agent_name,
                        content: msg.content,
                        time: msg.timestamp,
                        characters: msg.character_count
                    }));
                    
                    const dataStr = JSON.stringify(conversation, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `multi-agent-chat-${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                })
                .catch(error => {
                    console.error('Error exporting conversation:', error);
                    alert('Error exporting conversation');
                });
        }
    </script>
</body>
</html>
